(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{212:function(e,n){e.exports={body:'## ¿Qué son las Skeleton Screens?\n\nSeguramente Facebook o Linkedin han sido los principales impulsores de los llamados Skeleton Screens. Solo tienes que entrar con tu cuenta de usuario y verás una barras que se mueven y que dan la sensación de que el contenido está cargándose.\n\nLas Skeleton Screens sirven para mostrar contenido instantáneo antes de tener el contenido final que cargamos de <strong>forma asíncrona</strong>.\n¿Asíncrona? ¿qué es eso?\nContenido asíncrono es todo el contenido que tenemos que "esperar" a que se carge habiendo un retraso temporal. La gran mayoría de los casos es contenido que viene de una petición a un servidor (a través de las famosas APIs) y que esperamos desde el front-end recibirlo pero no sabemos cuándo y eso no impide que se pueda mostrar el resto de la página. Escribiré más sobre ello en otro post, por ahora es importante simplemente saber que <strong>el contenido asíncrono es el que no se carga instantáneamente, sino que tenemos que esperar para obtenerlo</strong>.\n\n## ¿Por qué son importantes las Skeleton Screens para el UX?\n\nLas Skeleton Screen son muy importantes porque sirven para comunicar al usuario que va a recibir un contenido próximamente. El usuario no necesita saber que estamos haciendo una petición a una API que tarda 2 segundos en devolvernos la información, simplemente necesita saber que la página no ha terminado de cargar y que pronto obtendrá esa información. Son muy parecidos a los loaders, solo que se diferencian en que se <strong>asemejan al contenido final</strong> para que el usuario sepa qué es lo que va a recibir y tener contexto.\n\nEn este post vamos a ver cómo <strong>diseñar e implementar un Skeleton Screen</strong> para un ejemplo concreto y complejo: <strong>una tabla de contenido.</strong>\nEs un ejemplo real que hice para un proyecto de [Holaluz](https://www.holaluz.com/) pero he cambiado el CSS al estilo de mi web y el contenido de las tablas por bandas de música que me gustan, mucho más interesante que contratos eléctricos ;)\n\n## Diseñar un Skeleton Screen\n\n### Paso 1: distinguir el contenido asíncrono\n\nPara empezar el diseño necesitamos saber qué contenido será asíncrono en la carga y qué contenido no lo será, será síncrono. Si solo nos encargamos de la parte de diseño o acabamos de aterrizar en el proyecto, tendremos que preguntar a nuestros compañeros de front-end qué contenido va a enviar la API y lo más importante: qué contenido ya sabemos que vamos a mostrar.\n\nEn este caso, yo como UX Engineer en este proyecto (trabajo en el diseño y en el desarrollo), ya tenía esta información y podía distinguir entre:\n- <strong>Contenido síncrono:</strong> la estructura de la tabla con sus titulares, que tiene 3 columnas de las cuales sé su alto.\n- <strong>Contenido asíncrono:</strong> el contenido de cada fila que la API devolverá como un objeto. Cada fila se divide en 3 columnas.\n\nEste es el esquema gráfico que necesitamos saber antes de coger nuestra herramienta de diseño:\n\n<image-responsive imageURL="blog/design-and-code-skeletons-screens/scheme.jpg" width="100%" alt="Foto del esquema donde se representa el contenido asíncrono y síncrono"/>\n\nLos rectángulos morados representan el contenido síncrono y los rectángulos verdes el asíncrono.\n\n### Paso 2: Vamos a diseñar el skeleton screen con elementos planos para suplir y representar el contenido asíncrono.\n\nY aquí viene la complicación: <strong>no sabemos cuantas columnas de contenido asíncrono nos va a devolver la API ni la longitud de su contenido</strong> y no tenemos forma de saberlo porque siempre será diferente en función del usuario o filtros. Tenemos que crear un diseño que sirva para todas las opciones posibles, ya devuelva una fila o 50 filas de contenido cuando termine la petición.\n\nPara ello hay recursos visuales que podemos utilizar, en este caso opté por plasmar 3 filas que tuvieran opacidades diferentes hasta mezclarse en el fondo final y 3 columnas en cada fila con longitudes random.\nAsí conseguimos la sensación visual de que hay un contenido de filas indefinido. Y que cada fila tiene columnas de longitud indefinidas.\n\n<image-responsive imageURL="blog/design-and-code-skeletons-screens/design.jpg" width="100%" alt="Foto del diseño final"/>\n\nLos loaders y los skeleton screens son característicos por sus animaciones ya que hace que nuestro cerebro piense que están pasando cosas y que ese elemento está activo.\n\nEn este caso aplicaremos dos animaciones, una vertical que mostrará una fila después de otra y también las retirará una vez que estén las 3 cargadas y la más famosa, característica y difícil de hacer: una animación de izquierda a derecha donde una línea vertical recorre el contenido. Algo parecido a esto:\n\n<img src="https://www.illuminz.com/api/wp-content/uploads/2017/12/loader.gif" alt="Loader" width="100%">\n\n<br>\n\nLas pequeñas animaciones no las suelo diseñar, ya que directamente las programo en CSS por rapidez y por ser realista con el tipo de animación que puedo hacer. Lo que sí que hago es buscar recursos y tener la idea en la cabeza que luego desarrollaré en CSS. Entiendo que muchos diseñadores trabajen en animaciones detalladas pero en mi caso como UX Engineer, donde puedo aplicarlas directamente en código, me es más fácil, realista y rápido de esta forma. De todas formas, si tienes que desarrollar animaciones, transiciones o flujos complejos, te recomiendo siempre diseñarlas antes. Utiliza la herramienta que necesites en el momento adecuado.\n\n## Programar un Skeleton Screen gracias a modos de opacidad de Sketch o Photoshop\n\nTeniendo en cuenta que ya tenemos la tabla maquetada y es esta:\n\n<Component :is="extraComponentLoader" :blend="false" :verticalAnimation="false" :horizontalAnimation="false" :isLoading="false" />\n\n### Paso 1: Maquetar las 3 filas con el contenido falso.\n\nPara ello haremos un <inline-code>tbody</inline-code> alternativo al de la tabla real que se enseñará si se cumple el booleano <inline-code>isLoading</inline-code>. Dentro de este <inline-code>tbody</inline-code> generaremos 3 rows donde cada una tiene las columnas que ya conocemos y cada columna tiene un <inline-code>div</inline-code> de anchura random. Esto lo estoy haciendo con Vue.js pero lo puedes hacer con cualquier otro framework, es solo modificar el template según una variable booleana que puede ser cambiada.\n\n```xml\n<tbody v-if="isLoading">\n  <tr\n    v-for="index in 3"\n    :key="index"\n    class="datagrid__row"\n  >\n    <td\n      v-for="column in columns"\n      :key="column.title"\n    >\n      <span>\n        <div\n          class="datagrid__loader"\n          :style="`width: ${Math.floor(Math.random() * 51) + 50}%;`"\n        />\n      </span>\n    </td>\n  </tr>\n</tbody>\n```\n\nResultado:\n\n<Component :is="extraComponentLoader" :blend="false" :verticalAnimation="false" :horizontalAnimation="false" />\n\n### Paso 2: Crear la animación vertical\n\n<strong>Esta animación mostrará una fila después de otra y también las retirará una vez que estén las 3 cargadas. </strong> Primero la definimos y luego la aplicamos a <inline-code>datagrid__row</inline-code>. En las filas 2 y 3 les pondremos un delay para obtener el efecto deseado: una fila después de otra.\n\n```css\n@keyframes aniVertical {\n  0% {\n    opacity: 0;\n  }\n\n  50% {\n    opacity: 1;\n  }\n\n  100% {\n    opacity: 0;\n  }\n}\n\n.datagrid__row {\n  animation: aniVertical 3s ease;\n  animation-iteration-count: infinite;\n  animation-fill-mode: forwards;\n  opacity: 0;\n\n  &:nth-child(2) {\n    animation-delay: .5s;\n  }\n\n  &:nth-child(3) {\n    animation-delay: 1s;\n  }\n}\n```\n\n<Component :is="extraComponentLoader" :blend="false" :horizontalAnimation="false" />\n\n### Paso 3 - La parte más compleja de un Skeleton Screen: la animación horizontal.\n\nAhora tenemos que crear la animación de izquierda a derecha que hace el efecto de "carga", es una especie de barra que atraviesa el contenido y sin duda la más caracteristica de un Skeleton Screen. Pero nos encontramos con que es muy "difícil".\nLa razón es que esta animación tiene que pasar por diferentes divs de contenido. Y aún se complica más en una tabla donde la estructura del HTML es más compleja.\n\n<strong>Os voy a enseñar la opción más fácil que se me ha ocurrido para solucionar este problema.</strong>\n\nSe basa en utilizar propiedades que hemos visto en <strong>Photoshop o Sketch</strong> aplicadas a CSS. Los usuarios de estos programas conocéis las propiedades de opacidad de las capas. ¿Las reconocéis?\n\n<image-responsive\n    imageURL="blog/design-and-code-skeletons-screens/opacity-properties.png"\n    width="100%"\n    alt="Foto de propiedades de opacidad"/>\n\nUna de los modos de opacidad es <inline-code>overlay</inline-code>, que hace que los colores oscuros de la capa al que se la aplicamos solo se vean reflejados en otros colores oscuros de capas que están por debajo y por tanto no se apliquen a blancos.\n\nResulta que tenemos disponibles estas mismas propiedades en CSS a través de <inline-code>mix-blend-mode</inline-code>. Esto nos viene genial para solucionar el problema de tener diferentes divs de contenido por el que la animación tiene que pasar.\n\nAplicaremos un <inline-code>:before</inline-code> a <inline-code>datagrid__row</inline-code> con una posición absoluta a su elemento para que ocupe y esté por encima de toda la fila y después crearemos una animación, <inline-code>aniHorizontal</inline-code>, que recorra el contenido.\n\n```css\n@keyframes aniHorizontal {\n  0% {\n    background-position: -100% 0;\n  }\n\n  100% {\n    background-position: 100% 0;\n  }\n}\n\n.datagrid__row {\n  position: relative;\n}\n\n.datagrid__row:before {\n  content: "";\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  animation-name: aniHorizontal;\n  animation-duration: 3.5s;\n  animation-timing-function: linear;\n  animation-iteration-count: infinite;\n  background: linear-gradient(\n    to right,\n    #cccccc 2%,\n    #666666 18%,\n    #cccccc 33%\n  );\n  background-size: 50%;\n}\n```\n\nResultado:\n\n<Component :is="extraComponentLoader" :blend="false" />\n\nPor último aplicamos el <inline-code>mix-blend-mode: overlay</inline-code> y mágicamente conseguimos que se junten las animaciones verticales y horizontales.\n\n```css\n.datagrid__row:before {\n  mix-blend-mode: overlay;\n}\n```\nResultado:\n\n<Component :is="extraComponentLoader" />\n\n## Juega con el resultado final\n\nTodos los ejemplos que has visto anteriormente no son imágenes ni videos, son un único componente de Vue que he cambiado en cada caso modificando sus props.\nAhora puedes jugar con esta variación del componente dándole click al checkbox de <inline-code>loading</inline-code> que hará que cambie el estado de normal a cargando.\n\n<Component :is="extraComponentLoader" checkbox :isLoading="false" />\n\nEn una aplicación real, la variable de <inline-code>isLoading</inline-code> vendrá dada por el sistema con el que se implemente la carga asíncrona y también será booleana como este checkbox.\n\n## Cosas a tener en cuenta sobre blend-mode\n\n- La propiedad de CSS <inline-code>mix-blend-mode: overlay</inline-code> sólo funciona si los fondos de las filas son totalmente blancos o totalmente negros (la gran mayoría de los casos).\n\n- <inline-code>Mix-blend-mode</inline-code> por ahora no está disponible para IE o Edge. Pero esto cambiará dentro de un tiempo según [Microsoft](https://developer.microsoft.com/en-us/microsoft-edge/platform/status/mixblendmode/). Puedes ver su soporte [aquí](https://caniuse.com/#feat=css-mixblendmode)\n\nSi lo que quieres es crear un Skeleton Screen sobre fondo que no sea blanco o negro, o tienes que soportar IE o Edge, te aconsejo esta [otra solución que utiliza SVG](http://danilowoz.com/create-vue-content-loader/). Es mucho más compleja, no estoy segura de que puedas hacerlo entre diferentes divs y requiere que utilices un paquete externo pero es la mejor alternativa que he podido encontrar.\n\nSi te ha gustado este tutorial o las canciones de la playlist puedes seguirme en [Twitter](https://twitter.com/MarinaAisa) y continuar la conversación por allí.\n¡Todo feedback es bienvenido! Si crees que hay algo que se puede mejorar me ayudarías muchísimo.',html:'<h2>¿Qué son las Skeleton Screens?</h2>\n<p>Seguramente Facebook o Linkedin han sido los principales impulsores de los llamados Skeleton Screens. Solo tienes que entrar con tu cuenta de usuario y verás una barras que se mueven y que dan la sensación de que el contenido está cargándose.</p>\n<p>Las Skeleton Screens sirven para mostrar contenido instantáneo antes de tener el contenido final que cargamos de <strong>forma asíncrona</strong>.\n¿Asíncrona? ¿qué es eso?\nContenido asíncrono es todo el contenido que tenemos que &quot;esperar&quot; a que se carge habiendo un retraso temporal. La gran mayoría de los casos es contenido que viene de una petición a un servidor (a través de las famosas APIs) y que esperamos desde el front-end recibirlo pero no sabemos cuándo y eso no impide que se pueda mostrar el resto de la página. Escribiré más sobre ello en otro post, por ahora es importante simplemente saber que <strong>el contenido asíncrono es el que no se carga instantáneamente, sino que tenemos que esperar para obtenerlo</strong>.</p>\n<h2>¿Por qué son importantes las Skeleton Screens para el UX?</h2>\n<p>Las Skeleton Screen son muy importantes porque sirven para comunicar al usuario que va a recibir un contenido próximamente. El usuario no necesita saber que estamos haciendo una petición a una API que tarda 2 segundos en devolvernos la información, simplemente necesita saber que la página no ha terminado de cargar y que pronto obtendrá esa información. Son muy parecidos a los loaders, solo que se diferencian en que se <strong>asemejan al contenido final</strong> para que el usuario sepa qué es lo que va a recibir y tener contexto.</p>\n<p>En este post vamos a ver cómo <strong>diseñar e implementar un Skeleton Screen</strong> para un ejemplo concreto y complejo: <strong>una tabla de contenido.</strong>\nEs un ejemplo real que hice para un proyecto de <a href="https://www.holaluz.com/">Holaluz</a> pero he cambiado el CSS al estilo de mi web y el contenido de las tablas por bandas de música que me gustan, mucho más interesante que contratos eléctricos ;)</p>\n<h2>Diseñar un Skeleton Screen</h2>\n<h3>Paso 1: distinguir el contenido asíncrono</h3>\n<p>Para empezar el diseño necesitamos saber qué contenido será asíncrono en la carga y qué contenido no lo será, será síncrono. Si solo nos encargamos de la parte de diseño o acabamos de aterrizar en el proyecto, tendremos que preguntar a nuestros compañeros de front-end qué contenido va a enviar la API y lo más importante: qué contenido ya sabemos que vamos a mostrar.</p>\n<p>En este caso, yo como UX Engineer en este proyecto (trabajo en el diseño y en el desarrollo), ya tenía esta información y podía distinguir entre:</p>\n<ul>\n<li><strong>Contenido síncrono:</strong> la estructura de la tabla con sus titulares, que tiene 3 columnas de las cuales sé su alto.</li>\n<li><strong>Contenido asíncrono:</strong> el contenido de cada fila que la API devolverá como un objeto. Cada fila se divide en 3 columnas.</li>\n</ul>\n<p>Este es el esquema gráfico que necesitamos saber antes de coger nuestra herramienta de diseño:</p>\n<image-responsive imageURL="blog/design-and-code-skeletons-screens/scheme.jpg" width="100%" alt="Foto del esquema donde se representa el contenido asíncrono y síncrono"/>\n<p>Los rectángulos morados representan el contenido síncrono y los rectángulos verdes el asíncrono.</p>\n<h3>Paso 2: Vamos a diseñar el skeleton screen con elementos planos para suplir y representar el contenido asíncrono.</h3>\n<p>Y aquí viene la complicación: <strong>no sabemos cuantas columnas de contenido asíncrono nos va a devolver la API ni la longitud de su contenido</strong> y no tenemos forma de saberlo porque siempre será diferente en función del usuario o filtros. Tenemos que crear un diseño que sirva para todas las opciones posibles, ya devuelva una fila o 50 filas de contenido cuando termine la petición.</p>\n<p>Para ello hay recursos visuales que podemos utilizar, en este caso opté por plasmar 3 filas que tuvieran opacidades diferentes hasta mezclarse en el fondo final y 3 columnas en cada fila con longitudes random.\nAsí conseguimos la sensación visual de que hay un contenido de filas indefinido. Y que cada fila tiene columnas de longitud indefinidas.</p>\n<image-responsive imageURL="blog/design-and-code-skeletons-screens/design.jpg" width="100%" alt="Foto del diseño final"/>\n<p>Los loaders y los skeleton screens son característicos por sus animaciones ya que hace que nuestro cerebro piense que están pasando cosas y que ese elemento está activo.</p>\n<p>En este caso aplicaremos dos animaciones, una vertical que mostrará una fila después de otra y también las retirará una vez que estén las 3 cargadas y la más famosa, característica y difícil de hacer: una animación de izquierda a derecha donde una línea vertical recorre el contenido. Algo parecido a esto:</p>\n<img src="https://www.illuminz.com/api/wp-content/uploads/2017/12/loader.gif" alt="Loader" width="100%">\n<br>\n<p>Las pequeñas animaciones no las suelo diseñar, ya que directamente las programo en CSS por rapidez y por ser realista con el tipo de animación que puedo hacer. Lo que sí que hago es buscar recursos y tener la idea en la cabeza que luego desarrollaré en CSS. Entiendo que muchos diseñadores trabajen en animaciones detalladas pero en mi caso como UX Engineer, donde puedo aplicarlas directamente en código, me es más fácil, realista y rápido de esta forma. De todas formas, si tienes que desarrollar animaciones, transiciones o flujos complejos, te recomiendo siempre diseñarlas antes. Utiliza la herramienta que necesites en el momento adecuado.</p>\n<h2>Programar un Skeleton Screen gracias a modos de opacidad de Sketch o Photoshop</h2>\n<p>Teniendo en cuenta que ya tenemos la tabla maquetada y es esta:</p>\n<Component :is="extraComponentLoader" :blend="false" :verticalAnimation="false" :horizontalAnimation="false" :isLoading="false" />\n<h3>Paso 1: Maquetar las 3 filas con el contenido falso.</h3>\n<p>Para ello haremos un <inline-code>tbody</inline-code> alternativo al de la tabla real que se enseñará si se cumple el booleano <inline-code>isLoading</inline-code>. Dentro de este <inline-code>tbody</inline-code> generaremos 3 rows donde cada una tiene las columnas que ya conocemos y cada columna tiene un <inline-code>div</inline-code> de anchura random. Esto lo estoy haciendo con Vue.js pero lo puedes hacer con cualquier otro framework, es solo modificar el template según una variable booleana que puede ser cambiada.</p>\n<pre><code class="language-xml">&lt;tbody v-if=&quot;isLoading&quot;&gt;\n  &lt;tr\n    v-for=&quot;index in 3&quot;\n    :key=&quot;index&quot;\n    class=&quot;datagrid__row&quot;\n  &gt;\n    &lt;td\n      v-for=&quot;column in columns&quot;\n      :key=&quot;column.title&quot;\n    &gt;\n      &lt;span&gt;\n        &lt;div\n          class=&quot;datagrid__loader&quot;\n          :style=&quot;`width: ${Math.floor(Math.random() * 51) + 50}%;`&quot;\n        /&gt;\n      &lt;/span&gt;\n    &lt;/td&gt;\n  &lt;/tr&gt;\n&lt;/tbody&gt;\n</code></pre>\n<p>Resultado:</p>\n<Component :is="extraComponentLoader" :blend="false" :verticalAnimation="false" :horizontalAnimation="false" />\n<h3>Paso 2: Crear la animación vertical</h3>\n<p><strong>Esta animación mostrará una fila después de otra y también las retirará una vez que estén las 3 cargadas. </strong> Primero la definimos y luego la aplicamos a <inline-code>datagrid__row</inline-code>. En las filas 2 y 3 les pondremos un delay para obtener el efecto deseado: una fila después de otra.</p>\n<pre><code class="language-css">@keyframes aniVertical {\n  0% {\n    opacity: 0;\n  }\n\n  50% {\n    opacity: 1;\n  }\n\n  100% {\n    opacity: 0;\n  }\n}\n\n.datagrid__row {\n  animation: aniVertical 3s ease;\n  animation-iteration-count: infinite;\n  animation-fill-mode: forwards;\n  opacity: 0;\n\n  &amp;:nth-child(2) {\n    animation-delay: .5s;\n  }\n\n  &amp;:nth-child(3) {\n    animation-delay: 1s;\n  }\n}\n</code></pre>\n<Component :is="extraComponentLoader" :blend="false" :horizontalAnimation="false" />\n<h3>Paso 3 - La parte más compleja de un Skeleton Screen: la animación horizontal.</h3>\n<p>Ahora tenemos que crear la animación de izquierda a derecha que hace el efecto de &quot;carga&quot;, es una especie de barra que atraviesa el contenido y sin duda la más caracteristica de un Skeleton Screen. Pero nos encontramos con que es muy &quot;difícil&quot;.\nLa razón es que esta animación tiene que pasar por diferentes divs de contenido. Y aún se complica más en una tabla donde la estructura del HTML es más compleja.</p>\n<p><strong>Os voy a enseñar la opción más fácil que se me ha ocurrido para solucionar este problema.</strong></p>\n<p>Se basa en utilizar propiedades que hemos visto en <strong>Photoshop o Sketch</strong> aplicadas a CSS. Los usuarios de estos programas conocéis las propiedades de opacidad de las capas. ¿Las reconocéis?</p>\n<p><image-responsive\n    imageURL="blog/design-and-code-skeletons-screens/opacity-properties.png"\n    width="100%"\n    alt="Foto de propiedades de opacidad"/></p>\n<p>Una de los modos de opacidad es <inline-code>overlay</inline-code>, que hace que los colores oscuros de la capa al que se la aplicamos solo se vean reflejados en otros colores oscuros de capas que están por debajo y por tanto no se apliquen a blancos.</p>\n<p>Resulta que tenemos disponibles estas mismas propiedades en CSS a través de <inline-code>mix-blend-mode</inline-code>. Esto nos viene genial para solucionar el problema de tener diferentes divs de contenido por el que la animación tiene que pasar.</p>\n<p>Aplicaremos un <inline-code>:before</inline-code> a <inline-code>datagrid__row</inline-code> con una posición absoluta a su elemento para que ocupe y esté por encima de toda la fila y después crearemos una animación, <inline-code>aniHorizontal</inline-code>, que recorra el contenido.</p>\n<pre><code class="language-css">@keyframes aniHorizontal {\n  0% {\n    background-position: -100% 0;\n  }\n\n  100% {\n    background-position: 100% 0;\n  }\n}\n\n.datagrid__row {\n  position: relative;\n}\n\n.datagrid__row:before {\n  content: &quot;&quot;;\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  animation-name: aniHorizontal;\n  animation-duration: 3.5s;\n  animation-timing-function: linear;\n  animation-iteration-count: infinite;\n  background: linear-gradient(\n    to right,\n    #cccccc 2%,\n    #666666 18%,\n    #cccccc 33%\n  );\n  background-size: 50%;\n}\n</code></pre>\n<p>Resultado:</p>\n<Component :is="extraComponentLoader" :blend="false" />\n<p>Por último aplicamos el <inline-code>mix-blend-mode: overlay</inline-code> y mágicamente conseguimos que se junten las animaciones verticales y horizontales.</p>\n<pre><code class="language-css">.datagrid__row:before {\n  mix-blend-mode: overlay;\n}\n</code></pre>\n<p>Resultado:</p>\n<Component :is="extraComponentLoader" />\n<h2>Juega con el resultado final</h2>\n<p>Todos los ejemplos que has visto anteriormente no son imágenes ni videos, son un único componente de Vue que he cambiado en cada caso modificando sus props.\nAhora puedes jugar con esta variación del componente dándole click al checkbox de <inline-code>loading</inline-code> que hará que cambie el estado de normal a cargando.</p>\n<Component :is="extraComponentLoader" checkbox :isLoading="false" />\n<p>En una aplicación real, la variable de <inline-code>isLoading</inline-code> vendrá dada por el sistema con el que se implemente la carga asíncrona y también será booleana como este checkbox.</p>\n<h2>Cosas a tener en cuenta sobre blend-mode</h2>\n<ul>\n<li>\n<p>La propiedad de CSS <inline-code>mix-blend-mode: overlay</inline-code> sólo funciona si los fondos de las filas son totalmente blancos o totalmente negros (la gran mayoría de los casos).</p>\n</li>\n<li>\n<p><inline-code>Mix-blend-mode</inline-code> por ahora no está disponible para IE o Edge. Pero esto cambiará dentro de un tiempo según <a href="https://developer.microsoft.com/en-us/microsoft-edge/platform/status/mixblendmode/">Microsoft</a>. Puedes ver su soporte <a href="https://caniuse.com/#feat=css-mixblendmode">aquí</a></p>\n</li>\n</ul>\n<p>Si lo que quieres es crear un Skeleton Screen sobre fondo que no sea blanco o negro, o tienes que soportar IE o Edge, te aconsejo esta <a href="http://danilowoz.com/create-vue-content-loader/">otra solución que utiliza SVG</a>. Es mucho más compleja, no estoy segura de que puedas hacerlo entre diferentes divs y requiere que utilices un paquete externo pero es la mejor alternativa que he podido encontrar.</p>\n<p>Si te ha gustado este tutorial o las canciones de la playlist puedes seguirme en <a href="https://twitter.com/MarinaAisa">Twitter</a> y continuar la conversación por allí.\n¡Todo feedback es bienvenido! Si crees que hay algo que se puede mejorar me ayudarías muchísimo.</p>\n',attributes:{name:"disena-programa-skeletons-screens",trans:"design-and-code-skeletons-screens",title:"Diseña y programa responsive Skeleton Screens",year:"1 Mayo 2019",color:"#edece7",isTextColorDark:!0,noMainImage:!0,extraComponent:"Datatable",id:"design-and-code-skeletons-screens",description:"Aprenderás a diseñar un Skeleton Screen pensando en su asincronometría y programarlo en base a modos de opacidad de Sketch o Photoshop.\n",_meta:{resourcePath:"/var/www/html/nuxt-markdown-blog-starter/contents/tr/blog/disena-programa-skeletons-screens.md"}},vue:{render:'return function render() { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'div\',{staticClass:"dynamicMarkdown"},[_c(\'h2\',[_vm._v("¿Qué son las Skeleton Screens?")]),_vm._v(" "),_c(\'p\',[_vm._v("Seguramente Facebook o Linkedin han sido los principales impulsores de los llamados Skeleton Screens. Solo tienes que entrar con tu cuenta de usuario y verás una barras que se mueven y que dan la sensación de que el contenido está cargándose.")]),_vm._v(" "),_vm._m(0),_vm._v(" "),_c(\'h2\',[_vm._v("¿Por qué son importantes las Skeleton Screens para el UX?")]),_vm._v(" "),_vm._m(1),_vm._v(" "),_vm._m(2),_vm._v(" "),_c(\'h2\',[_vm._v("Diseñar un Skeleton Screen")]),_vm._v(" "),_c(\'h3\',[_vm._v("Paso 1: distinguir el contenido asíncrono")]),_vm._v(" "),_c(\'p\',[_vm._v("Para empezar el diseño necesitamos saber qué contenido será asíncrono en la carga y qué contenido no lo será, será síncrono. Si solo nos encargamos de la parte de diseño o acabamos de aterrizar en el proyecto, tendremos que preguntar a nuestros compañeros de front-end qué contenido va a enviar la API y lo más importante: qué contenido ya sabemos que vamos a mostrar.")]),_vm._v(" "),_c(\'p\',[_vm._v("En este caso, yo como UX Engineer en este proyecto (trabajo en el diseño y en el desarrollo), ya tenía esta información y podía distinguir entre:")]),_vm._v(" "),_vm._m(3),_vm._v(" "),_c(\'p\',[_vm._v("Este es el esquema gráfico que necesitamos saber antes de coger nuestra herramienta de diseño:")]),_vm._v(" "),_c(\'image-responsive\',{attrs:{"imageURL":"blog/design-and-code-skeletons-screens/scheme.jpg","width":"100%","alt":"Foto del esquema donde se representa el contenido asíncrono y síncrono"}}),_vm._v(" "),_c(\'p\',[_vm._v("Los rectángulos morados representan el contenido síncrono y los rectángulos verdes el asíncrono.")]),_vm._v(" "),_c(\'h3\',[_vm._v("Paso 2: Vamos a diseñar el skeleton screen con elementos planos para suplir y representar el contenido asíncrono.")]),_vm._v(" "),_vm._m(4),_vm._v(" "),_c(\'p\',[_vm._v("Para ello hay recursos visuales que podemos utilizar, en este caso opté por plasmar 3 filas que tuvieran opacidades diferentes hasta mezclarse en el fondo final y 3 columnas en cada fila con longitudes random.\\nAsí conseguimos la sensación visual de que hay un contenido de filas indefinido. Y que cada fila tiene columnas de longitud indefinidas.")]),_vm._v(" "),_c(\'image-responsive\',{attrs:{"imageURL":"blog/design-and-code-skeletons-screens/design.jpg","width":"100%","alt":"Foto del diseño final"}}),_vm._v(" "),_c(\'p\',[_vm._v("Los loaders y los skeleton screens son característicos por sus animaciones ya que hace que nuestro cerebro piense que están pasando cosas y que ese elemento está activo.")]),_vm._v(" "),_c(\'p\',[_vm._v("En este caso aplicaremos dos animaciones, una vertical que mostrará una fila después de otra y también las retirará una vez que estén las 3 cargadas y la más famosa, característica y difícil de hacer: una animación de izquierda a derecha donde una línea vertical recorre el contenido. Algo parecido a esto:")]),_vm._v(" "),_c(\'img\',{attrs:{"src":"https://www.illuminz.com/api/wp-content/uploads/2017/12/loader.gif","alt":"Loader","width":"100%"}}),_vm._v(" "),_c(\'br\'),_vm._v(" "),_c(\'p\',[_vm._v("Las pequeñas animaciones no las suelo diseñar, ya que directamente las programo en CSS por rapidez y por ser realista con el tipo de animación que puedo hacer. Lo que sí que hago es buscar recursos y tener la idea en la cabeza que luego desarrollaré en CSS. Entiendo que muchos diseñadores trabajen en animaciones detalladas pero en mi caso como UX Engineer, donde puedo aplicarlas directamente en código, me es más fácil, realista y rápido de esta forma. De todas formas, si tienes que desarrollar animaciones, transiciones o flujos complejos, te recomiendo siempre diseñarlas antes. Utiliza la herramienta que necesites en el momento adecuado.")]),_vm._v(" "),_c(\'h2\',[_vm._v("Programar un Skeleton Screen gracias a modos de opacidad de Sketch o Photoshop")]),_vm._v(" "),_c(\'p\',[_vm._v("Teniendo en cuenta que ya tenemos la tabla maquetada y es esta:")]),_vm._v(" "),_c(_vm.extraComponentLoader,{tag:"Component",attrs:{"blend":false,"verticalAnimation":false,"horizontalAnimation":false,"isLoading":false}}),_vm._v(" "),_c(\'h3\',[_vm._v("Paso 1: Maquetar las 3 filas con el contenido falso.")]),_vm._v(" "),_c(\'p\',[_vm._v("Para ello haremos un "),_c(\'inline-code\',[_vm._v("tbody")]),_vm._v(" alternativo al de la tabla real que se enseñará si se cumple el booleano "),_c(\'inline-code\',[_vm._v("isLoading")]),_vm._v(". Dentro de este "),_c(\'inline-code\',[_vm._v("tbody")]),_vm._v(" generaremos 3 rows donde cada una tiene las columnas que ya conocemos y cada columna tiene un "),_c(\'inline-code\',[_vm._v("div")]),_vm._v(" de anchura random. Esto lo estoy haciendo con Vue.js pero lo puedes hacer con cualquier otro framework, es solo modificar el template según una variable booleana que puede ser cambiada.")],1),_vm._v(" "),_vm._m(5),_vm._v(" "),_c(\'p\',[_vm._v("Resultado:")]),_vm._v(" "),_c(_vm.extraComponentLoader,{tag:"Component",attrs:{"blend":false,"verticalAnimation":false,"horizontalAnimation":false}}),_vm._v(" "),_c(\'h3\',[_vm._v("Paso 2: Crear la animación vertical")]),_vm._v(" "),_c(\'p\',[_c(\'strong\',[_vm._v("Esta animación mostrará una fila después de otra y también las retirará una vez que estén las 3 cargadas. ")]),_vm._v(" Primero la definimos y luego la aplicamos a "),_c(\'inline-code\',[_vm._v("datagrid__row")]),_vm._v(". En las filas 2 y 3 les pondremos un delay para obtener el efecto deseado: una fila después de otra.")],1),_vm._v(" "),_vm._m(6),_vm._v(" "),_c(_vm.extraComponentLoader,{tag:"Component",attrs:{"blend":false,"horizontalAnimation":false}}),_vm._v(" "),_c(\'h3\',[_vm._v("Paso 3 - La parte más compleja de un Skeleton Screen: la animación horizontal.")]),_vm._v(" "),_c(\'p\',[_vm._v("Ahora tenemos que crear la animación de izquierda a derecha que hace el efecto de \\"carga\\", es una especie de barra que atraviesa el contenido y sin duda la más caracteristica de un Skeleton Screen. Pero nos encontramos con que es muy \\"difícil\\".\\nLa razón es que esta animación tiene que pasar por diferentes divs de contenido. Y aún se complica más en una tabla donde la estructura del HTML es más compleja.")]),_vm._v(" "),_vm._m(7),_vm._v(" "),_vm._m(8),_vm._v(" "),_c(\'p\',[_c(\'image-responsive\',{attrs:{"imageURL":"blog/design-and-code-skeletons-screens/opacity-properties.png","width":"100%","alt":"Foto de propiedades de opacidad"}})],1),_vm._v(" "),_c(\'p\',[_vm._v("Una de los modos de opacidad es "),_c(\'inline-code\',[_vm._v("overlay")]),_vm._v(", que hace que los colores oscuros de la capa al que se la aplicamos solo se vean reflejados en otros colores oscuros de capas que están por debajo y por tanto no se apliquen a blancos.")],1),_vm._v(" "),_c(\'p\',[_vm._v("Resulta que tenemos disponibles estas mismas propiedades en CSS a través de "),_c(\'inline-code\',[_vm._v("mix-blend-mode")]),_vm._v(". Esto nos viene genial para solucionar el problema de tener diferentes divs de contenido por el que la animación tiene que pasar.")],1),_vm._v(" "),_c(\'p\',[_vm._v("Aplicaremos un "),_c(\'inline-code\',[_vm._v(":before")]),_vm._v(" a "),_c(\'inline-code\',[_vm._v("datagrid__row")]),_vm._v(" con una posición absoluta a su elemento para que ocupe y esté por encima de toda la fila y después crearemos una animación, "),_c(\'inline-code\',[_vm._v("aniHorizontal")]),_vm._v(", que recorra el contenido.")],1),_vm._v(" "),_vm._m(9),_vm._v(" "),_c(\'p\',[_vm._v("Resultado:")]),_vm._v(" "),_c(_vm.extraComponentLoader,{tag:"Component",attrs:{"blend":false}}),_vm._v(" "),_c(\'p\',[_vm._v("Por último aplicamos el "),_c(\'inline-code\',[_vm._v("mix-blend-mode: overlay")]),_vm._v(" y mágicamente conseguimos que se junten las animaciones verticales y horizontales.")],1),_vm._v(" "),_vm._m(10),_vm._v(" "),_c(\'p\',[_vm._v("Resultado:")]),_vm._v(" "),_c(_vm.extraComponentLoader,{tag:"Component"}),_vm._v(" "),_c(\'h2\',[_vm._v("Juega con el resultado final")]),_vm._v(" "),_c(\'p\',[_vm._v("Todos los ejemplos que has visto anteriormente no son imágenes ni videos, son un único componente de Vue que he cambiado en cada caso modificando sus props.\\nAhora puedes jugar con esta variación del componente dándole click al checkbox de "),_c(\'inline-code\',[_vm._v("loading")]),_vm._v(" que hará que cambie el estado de normal a cargando.")],1),_vm._v(" "),_c(_vm.extraComponentLoader,{tag:"Component",attrs:{"checkbox":"","isLoading":false}}),_vm._v(" "),_c(\'p\',[_vm._v("En una aplicación real, la variable de "),_c(\'inline-code\',[_vm._v("isLoading")]),_vm._v(" vendrá dada por el sistema con el que se implemente la carga asíncrona y también será booleana como este checkbox.")],1),_vm._v(" "),_c(\'h2\',[_vm._v("Cosas a tener en cuenta sobre blend-mode")]),_vm._v(" "),_c(\'ul\',[_c(\'li\',[_c(\'p\',[_vm._v("La propiedad de CSS "),_c(\'inline-code\',[_vm._v("mix-blend-mode: overlay")]),_vm._v(" sólo funciona si los fondos de las filas son totalmente blancos o totalmente negros (la gran mayoría de los casos).")],1)]),_vm._v(" "),_c(\'li\',[_c(\'p\',[_c(\'inline-code\',[_vm._v("Mix-blend-mode")]),_vm._v(" por ahora no está disponible para IE o Edge. Pero esto cambiará dentro de un tiempo según "),_c(\'a\',{attrs:{"href":"https://developer.microsoft.com/en-us/microsoft-edge/platform/status/mixblendmode/"}},[_vm._v("Microsoft")]),_vm._v(". Puedes ver su soporte "),_c(\'a\',{attrs:{"href":"https://caniuse.com/#feat=css-mixblendmode"}},[_vm._v("aquí")])],1)])]),_vm._v(" "),_vm._m(11),_vm._v(" "),_vm._m(12)],1) }',staticRenderFns:'return [function () { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'p\',[_vm._v("Las Skeleton Screens sirven para mostrar contenido instantáneo antes de tener el contenido final que cargamos de "),_c(\'strong\',[_vm._v("forma asíncrona")]),_vm._v(".\\n¿Asíncrona? ¿qué es eso?\\nContenido asíncrono es todo el contenido que tenemos que \\"esperar\\" a que se carge habiendo un retraso temporal. La gran mayoría de los casos es contenido que viene de una petición a un servidor (a través de las famosas APIs) y que esperamos desde el front-end recibirlo pero no sabemos cuándo y eso no impide que se pueda mostrar el resto de la página. Escribiré más sobre ello en otro post, por ahora es importante simplemente saber que "),_c(\'strong\',[_vm._v("el contenido asíncrono es el que no se carga instantáneamente, sino que tenemos que esperar para obtenerlo")]),_vm._v(".")]) },function () { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'p\',[_vm._v("Las Skeleton Screen son muy importantes porque sirven para comunicar al usuario que va a recibir un contenido próximamente. El usuario no necesita saber que estamos haciendo una petición a una API que tarda 2 segundos en devolvernos la información, simplemente necesita saber que la página no ha terminado de cargar y que pronto obtendrá esa información. Son muy parecidos a los loaders, solo que se diferencian en que se "),_c(\'strong\',[_vm._v("asemejan al contenido final")]),_vm._v(" para que el usuario sepa qué es lo que va a recibir y tener contexto.")]) },function () { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'p\',[_vm._v("En este post vamos a ver cómo "),_c(\'strong\',[_vm._v("diseñar e implementar un Skeleton Screen")]),_vm._v(" para un ejemplo concreto y complejo: "),_c(\'strong\',[_vm._v("una tabla de contenido.")]),_vm._v("\\nEs un ejemplo real que hice para un proyecto de "),_c(\'a\',{attrs:{"href":"https://www.holaluz.com/"}},[_vm._v("Holaluz")]),_vm._v(" pero he cambiado el CSS al estilo de mi web y el contenido de las tablas por bandas de música que me gustan, mucho más interesante que contratos eléctricos ;)")]) },function () { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'ul\',[_c(\'li\',[_c(\'strong\',[_vm._v("Contenido síncrono:")]),_vm._v(" la estructura de la tabla con sus titulares, que tiene 3 columnas de las cuales sé su alto.")]),_vm._v(" "),_c(\'li\',[_c(\'strong\',[_vm._v("Contenido asíncrono:")]),_vm._v(" el contenido de cada fila que la API devolverá como un objeto. Cada fila se divide en 3 columnas.")])]) },function () { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'p\',[_vm._v("Y aquí viene la complicación: "),_c(\'strong\',[_vm._v("no sabemos cuantas columnas de contenido asíncrono nos va a devolver la API ni la longitud de su contenido")]),_vm._v(" y no tenemos forma de saberlo porque siempre será diferente en función del usuario o filtros. Tenemos que crear un diseño que sirva para todas las opciones posibles, ya devuelva una fila o 50 filas de contenido cuando termine la petición.")]) },function () { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-xml"}},[_vm._v("<tbody v-if=\\"isLoading\\">\\n  <tr\\n    v-for=\\"index in 3\\"\\n    :key=\\"index\\"\\n    class=\\"datagrid__row\\"\\n  >\\n    <td\\n      v-for=\\"column in columns\\"\\n      :key=\\"column.title\\"\\n    >\\n      <span>\\n        <div\\n          class=\\"datagrid__loader\\"\\n          :style=\\"`width: ${Math.floor(Math.random() * 51) + 50}%;`\\"\\n        />\\n      </span>\\n    </td>\\n  </tr>\\n</tbody>\\n")])]) },function () { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-css"}},[_vm._v("@keyframes aniVertical {\\n  0% {\\n    opacity: 0;\\n  }\\n\\n  50% {\\n    opacity: 1;\\n  }\\n\\n  100% {\\n    opacity: 0;\\n  }\\n}\\n\\n.datagrid__row {\\n  animation: aniVertical 3s ease;\\n  animation-iteration-count: infinite;\\n  animation-fill-mode: forwards;\\n  opacity: 0;\\n\\n  &:nth-child(2) {\\n    animation-delay: .5s;\\n  }\\n\\n  &:nth-child(3) {\\n    animation-delay: 1s;\\n  }\\n}\\n")])]) },function () { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'p\',[_c(\'strong\',[_vm._v("Os voy a enseñar la opción más fácil que se me ha ocurrido para solucionar este problema.")])]) },function () { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'p\',[_vm._v("Se basa en utilizar propiedades que hemos visto en "),_c(\'strong\',[_vm._v("Photoshop o Sketch")]),_vm._v(" aplicadas a CSS. Los usuarios de estos programas conocéis las propiedades de opacidad de las capas. ¿Las reconocéis?")]) },function () { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-css"}},[_vm._v("@keyframes aniHorizontal {\\n  0% {\\n    background-position: -100% 0;\\n  }\\n\\n  100% {\\n    background-position: 100% 0;\\n  }\\n}\\n\\n.datagrid__row {\\n  position: relative;\\n}\\n\\n.datagrid__row:before {\\n  content: \\"\\";\\n  position: absolute;\\n  width: 100%;\\n  height: 100%;\\n  animation-name: aniHorizontal;\\n  animation-duration: 3.5s;\\n  animation-timing-function: linear;\\n  animation-iteration-count: infinite;\\n  background: linear-gradient(\\n    to right,\\n    #cccccc 2%,\\n    #666666 18%,\\n    #cccccc 33%\\n  );\\n  background-size: 50%;\\n}\\n")])]) },function () { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-css"}},[_vm._v(".datagrid__row:before {\\n  mix-blend-mode: overlay;\\n}\\n")])]) },function () { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'p\',[_vm._v("Si lo que quieres es crear un Skeleton Screen sobre fondo que no sea blanco o negro, o tienes que soportar IE o Edge, te aconsejo esta "),_c(\'a\',{attrs:{"href":"http://danilowoz.com/create-vue-content-loader/"}},[_vm._v("otra solución que utiliza SVG")]),_vm._v(". Es mucho más compleja, no estoy segura de que puedas hacerlo entre diferentes divs y requiere que utilices un paquete externo pero es la mejor alternativa que he podido encontrar.")]) },function () { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'p\',[_vm._v("Si te ha gustado este tutorial o las canciones de la playlist puedes seguirme en "),_c(\'a\',{attrs:{"href":"https://twitter.com/MarinaAisa"}},[_vm._v("Twitter")]),_vm._v(" y continuar la conversación por allí.\\n¡Todo feedback es bienvenido! Si crees que hay algo que se puede mejorar me ayudarías muchísimo.")]) }]',component:{data:function(){return{templateRender:null}},render:function(e){return this.templateRender?this.templateRender():e("div","Rendering")},created:function(){this.templateRender=function(){var e=this,n=e.$createElement,o=e._self._c||n;return o("div",{staticClass:"dynamicMarkdown"},[o("h2",[e._v("¿Qué son las Skeleton Screens?")]),e._v(" "),o("p",[e._v("Seguramente Facebook o Linkedin han sido los principales impulsores de los llamados Skeleton Screens. Solo tienes que entrar con tu cuenta de usuario y verás una barras que se mueven y que dan la sensación de que el contenido está cargándose.")]),e._v(" "),e._m(0),e._v(" "),o("h2",[e._v("¿Por qué son importantes las Skeleton Screens para el UX?")]),e._v(" "),e._m(1),e._v(" "),e._m(2),e._v(" "),o("h2",[e._v("Diseñar un Skeleton Screen")]),e._v(" "),o("h3",[e._v("Paso 1: distinguir el contenido asíncrono")]),e._v(" "),o("p",[e._v("Para empezar el diseño necesitamos saber qué contenido será asíncrono en la carga y qué contenido no lo será, será síncrono. Si solo nos encargamos de la parte de diseño o acabamos de aterrizar en el proyecto, tendremos que preguntar a nuestros compañeros de front-end qué contenido va a enviar la API y lo más importante: qué contenido ya sabemos que vamos a mostrar.")]),e._v(" "),o("p",[e._v("En este caso, yo como UX Engineer en este proyecto (trabajo en el diseño y en el desarrollo), ya tenía esta información y podía distinguir entre:")]),e._v(" "),e._m(3),e._v(" "),o("p",[e._v("Este es el esquema gráfico que necesitamos saber antes de coger nuestra herramienta de diseño:")]),e._v(" "),o("image-responsive",{attrs:{imageURL:"blog/design-and-code-skeletons-screens/scheme.jpg",width:"100%",alt:"Foto del esquema donde se representa el contenido asíncrono y síncrono"}}),e._v(" "),o("p",[e._v("Los rectángulos morados representan el contenido síncrono y los rectángulos verdes el asíncrono.")]),e._v(" "),o("h3",[e._v("Paso 2: Vamos a diseñar el skeleton screen con elementos planos para suplir y representar el contenido asíncrono.")]),e._v(" "),e._m(4),e._v(" "),o("p",[e._v("Para ello hay recursos visuales que podemos utilizar, en este caso opté por plasmar 3 filas que tuvieran opacidades diferentes hasta mezclarse en el fondo final y 3 columnas en cada fila con longitudes random.\nAsí conseguimos la sensación visual de que hay un contenido de filas indefinido. Y que cada fila tiene columnas de longitud indefinidas.")]),e._v(" "),o("image-responsive",{attrs:{imageURL:"blog/design-and-code-skeletons-screens/design.jpg",width:"100%",alt:"Foto del diseño final"}}),e._v(" "),o("p",[e._v("Los loaders y los skeleton screens son característicos por sus animaciones ya que hace que nuestro cerebro piense que están pasando cosas y que ese elemento está activo.")]),e._v(" "),o("p",[e._v("En este caso aplicaremos dos animaciones, una vertical que mostrará una fila después de otra y también las retirará una vez que estén las 3 cargadas y la más famosa, característica y difícil de hacer: una animación de izquierda a derecha donde una línea vertical recorre el contenido. Algo parecido a esto:")]),e._v(" "),o("img",{attrs:{src:"https://www.illuminz.com/api/wp-content/uploads/2017/12/loader.gif",alt:"Loader",width:"100%"}}),e._v(" "),o("br"),e._v(" "),o("p",[e._v("Las pequeñas animaciones no las suelo diseñar, ya que directamente las programo en CSS por rapidez y por ser realista con el tipo de animación que puedo hacer. Lo que sí que hago es buscar recursos y tener la idea en la cabeza que luego desarrollaré en CSS. Entiendo que muchos diseñadores trabajen en animaciones detalladas pero en mi caso como UX Engineer, donde puedo aplicarlas directamente en código, me es más fácil, realista y rápido de esta forma. De todas formas, si tienes que desarrollar animaciones, transiciones o flujos complejos, te recomiendo siempre diseñarlas antes. Utiliza la herramienta que necesites en el momento adecuado.")]),e._v(" "),o("h2",[e._v("Programar un Skeleton Screen gracias a modos de opacidad de Sketch o Photoshop")]),e._v(" "),o("p",[e._v("Teniendo en cuenta que ya tenemos la tabla maquetada y es esta:")]),e._v(" "),o(e.extraComponentLoader,{tag:"Component",attrs:{blend:!1,verticalAnimation:!1,horizontalAnimation:!1,isLoading:!1}}),e._v(" "),o("h3",[e._v("Paso 1: Maquetar las 3 filas con el contenido falso.")]),e._v(" "),o("p",[e._v("Para ello haremos un "),o("inline-code",[e._v("tbody")]),e._v(" alternativo al de la tabla real que se enseñará si se cumple el booleano "),o("inline-code",[e._v("isLoading")]),e._v(". Dentro de este "),o("inline-code",[e._v("tbody")]),e._v(" generaremos 3 rows donde cada una tiene las columnas que ya conocemos y cada columna tiene un "),o("inline-code",[e._v("div")]),e._v(" de anchura random. Esto lo estoy haciendo con Vue.js pero lo puedes hacer con cualquier otro framework, es solo modificar el template según una variable booleana que puede ser cambiada.")],1),e._v(" "),e._m(5),e._v(" "),o("p",[e._v("Resultado:")]),e._v(" "),o(e.extraComponentLoader,{tag:"Component",attrs:{blend:!1,verticalAnimation:!1,horizontalAnimation:!1}}),e._v(" "),o("h3",[e._v("Paso 2: Crear la animación vertical")]),e._v(" "),o("p",[o("strong",[e._v("Esta animación mostrará una fila después de otra y también las retirará una vez que estén las 3 cargadas. ")]),e._v(" Primero la definimos y luego la aplicamos a "),o("inline-code",[e._v("datagrid__row")]),e._v(". En las filas 2 y 3 les pondremos un delay para obtener el efecto deseado: una fila después de otra.")],1),e._v(" "),e._m(6),e._v(" "),o(e.extraComponentLoader,{tag:"Component",attrs:{blend:!1,horizontalAnimation:!1}}),e._v(" "),o("h3",[e._v("Paso 3 - La parte más compleja de un Skeleton Screen: la animación horizontal.")]),e._v(" "),o("p",[e._v('Ahora tenemos que crear la animación de izquierda a derecha que hace el efecto de "carga", es una especie de barra que atraviesa el contenido y sin duda la más caracteristica de un Skeleton Screen. Pero nos encontramos con que es muy "difícil".\nLa razón es que esta animación tiene que pasar por diferentes divs de contenido. Y aún se complica más en una tabla donde la estructura del HTML es más compleja.')]),e._v(" "),e._m(7),e._v(" "),e._m(8),e._v(" "),o("p",[o("image-responsive",{attrs:{imageURL:"blog/design-and-code-skeletons-screens/opacity-properties.png",width:"100%",alt:"Foto de propiedades de opacidad"}})],1),e._v(" "),o("p",[e._v("Una de los modos de opacidad es "),o("inline-code",[e._v("overlay")]),e._v(", que hace que los colores oscuros de la capa al que se la aplicamos solo se vean reflejados en otros colores oscuros de capas que están por debajo y por tanto no se apliquen a blancos.")],1),e._v(" "),o("p",[e._v("Resulta que tenemos disponibles estas mismas propiedades en CSS a través de "),o("inline-code",[e._v("mix-blend-mode")]),e._v(". Esto nos viene genial para solucionar el problema de tener diferentes divs de contenido por el que la animación tiene que pasar.")],1),e._v(" "),o("p",[e._v("Aplicaremos un "),o("inline-code",[e._v(":before")]),e._v(" a "),o("inline-code",[e._v("datagrid__row")]),e._v(" con una posición absoluta a su elemento para que ocupe y esté por encima de toda la fila y después crearemos una animación, "),o("inline-code",[e._v("aniHorizontal")]),e._v(", que recorra el contenido.")],1),e._v(" "),e._m(9),e._v(" "),o("p",[e._v("Resultado:")]),e._v(" "),o(e.extraComponentLoader,{tag:"Component",attrs:{blend:!1}}),e._v(" "),o("p",[e._v("Por último aplicamos el "),o("inline-code",[e._v("mix-blend-mode: overlay")]),e._v(" y mágicamente conseguimos que se junten las animaciones verticales y horizontales.")],1),e._v(" "),e._m(10),e._v(" "),o("p",[e._v("Resultado:")]),e._v(" "),o(e.extraComponentLoader,{tag:"Component"}),e._v(" "),o("h2",[e._v("Juega con el resultado final")]),e._v(" "),o("p",[e._v("Todos los ejemplos que has visto anteriormente no son imágenes ni videos, son un único componente de Vue que he cambiado en cada caso modificando sus props.\nAhora puedes jugar con esta variación del componente dándole click al checkbox de "),o("inline-code",[e._v("loading")]),e._v(" que hará que cambie el estado de normal a cargando.")],1),e._v(" "),o(e.extraComponentLoader,{tag:"Component",attrs:{checkbox:"",isLoading:!1}}),e._v(" "),o("p",[e._v("En una aplicación real, la variable de "),o("inline-code",[e._v("isLoading")]),e._v(" vendrá dada por el sistema con el que se implemente la carga asíncrona y también será booleana como este checkbox.")],1),e._v(" "),o("h2",[e._v("Cosas a tener en cuenta sobre blend-mode")]),e._v(" "),o("ul",[o("li",[o("p",[e._v("La propiedad de CSS "),o("inline-code",[e._v("mix-blend-mode: overlay")]),e._v(" sólo funciona si los fondos de las filas son totalmente blancos o totalmente negros (la gran mayoría de los casos).")],1)]),e._v(" "),o("li",[o("p",[o("inline-code",[e._v("Mix-blend-mode")]),e._v(" por ahora no está disponible para IE o Edge. Pero esto cambiará dentro de un tiempo según "),o("a",{attrs:{href:"https://developer.microsoft.com/en-us/microsoft-edge/platform/status/mixblendmode/"}},[e._v("Microsoft")]),e._v(". Puedes ver su soporte "),o("a",{attrs:{href:"https://caniuse.com/#feat=css-mixblendmode"}},[e._v("aquí")])],1)])]),e._v(" "),e._m(11),e._v(" "),e._m(12)],1)},this.$options.staticRenderFns=[function(){var e=this.$createElement,n=this._self._c||e;return n("p",[this._v("Las Skeleton Screens sirven para mostrar contenido instantáneo antes de tener el contenido final que cargamos de "),n("strong",[this._v("forma asíncrona")]),this._v('.\n¿Asíncrona? ¿qué es eso?\nContenido asíncrono es todo el contenido que tenemos que "esperar" a que se carge habiendo un retraso temporal. La gran mayoría de los casos es contenido que viene de una petición a un servidor (a través de las famosas APIs) y que esperamos desde el front-end recibirlo pero no sabemos cuándo y eso no impide que se pueda mostrar el resto de la página. Escribiré más sobre ello en otro post, por ahora es importante simplemente saber que '),n("strong",[this._v("el contenido asíncrono es el que no se carga instantáneamente, sino que tenemos que esperar para obtenerlo")]),this._v(".")])},function(){var e=this.$createElement,n=this._self._c||e;return n("p",[this._v("Las Skeleton Screen son muy importantes porque sirven para comunicar al usuario que va a recibir un contenido próximamente. El usuario no necesita saber que estamos haciendo una petición a una API que tarda 2 segundos en devolvernos la información, simplemente necesita saber que la página no ha terminado de cargar y que pronto obtendrá esa información. Son muy parecidos a los loaders, solo que se diferencian en que se "),n("strong",[this._v("asemejan al contenido final")]),this._v(" para que el usuario sepa qué es lo que va a recibir y tener contexto.")])},function(){var e=this.$createElement,n=this._self._c||e;return n("p",[this._v("En este post vamos a ver cómo "),n("strong",[this._v("diseñar e implementar un Skeleton Screen")]),this._v(" para un ejemplo concreto y complejo: "),n("strong",[this._v("una tabla de contenido.")]),this._v("\nEs un ejemplo real que hice para un proyecto de "),n("a",{attrs:{href:"https://www.holaluz.com/"}},[this._v("Holaluz")]),this._v(" pero he cambiado el CSS al estilo de mi web y el contenido de las tablas por bandas de música que me gustan, mucho más interesante que contratos eléctricos ;)")])},function(){var e=this.$createElement,n=this._self._c||e;return n("ul",[n("li",[n("strong",[this._v("Contenido síncrono:")]),this._v(" la estructura de la tabla con sus titulares, que tiene 3 columnas de las cuales sé su alto.")]),this._v(" "),n("li",[n("strong",[this._v("Contenido asíncrono:")]),this._v(" el contenido de cada fila que la API devolverá como un objeto. Cada fila se divide en 3 columnas.")])])},function(){var e=this.$createElement,n=this._self._c||e;return n("p",[this._v("Y aquí viene la complicación: "),n("strong",[this._v("no sabemos cuantas columnas de contenido asíncrono nos va a devolver la API ni la longitud de su contenido")]),this._v(" y no tenemos forma de saberlo porque siempre será diferente en función del usuario o filtros. Tenemos que crear un diseño que sirva para todas las opciones posibles, ya devuelva una fila o 50 filas de contenido cuando termine la petición.")])},function(){var e=this.$createElement,n=this._self._c||e;return n("pre",[n("code",{pre:!0,attrs:{class:"language-xml"}},[this._v('<tbody v-if="isLoading">\n  <tr\n    v-for="index in 3"\n    :key="index"\n    class="datagrid__row"\n  >\n    <td\n      v-for="column in columns"\n      :key="column.title"\n    >\n      <span>\n        <div\n          class="datagrid__loader"\n          :style="`width: ${Math.floor(Math.random() * 51) + 50}%;`"\n        />\n      </span>\n    </td>\n  </tr>\n</tbody>\n')])])},function(){var e=this.$createElement,n=this._self._c||e;return n("pre",[n("code",{pre:!0,attrs:{class:"language-css"}},[this._v("@keyframes aniVertical {\n  0% {\n    opacity: 0;\n  }\n\n  50% {\n    opacity: 1;\n  }\n\n  100% {\n    opacity: 0;\n  }\n}\n\n.datagrid__row {\n  animation: aniVertical 3s ease;\n  animation-iteration-count: infinite;\n  animation-fill-mode: forwards;\n  opacity: 0;\n\n  &:nth-child(2) {\n    animation-delay: .5s;\n  }\n\n  &:nth-child(3) {\n    animation-delay: 1s;\n  }\n}\n")])])},function(){var e=this.$createElement,n=this._self._c||e;return n("p",[n("strong",[this._v("Os voy a enseñar la opción más fácil que se me ha ocurrido para solucionar este problema.")])])},function(){var e=this.$createElement,n=this._self._c||e;return n("p",[this._v("Se basa en utilizar propiedades que hemos visto en "),n("strong",[this._v("Photoshop o Sketch")]),this._v(" aplicadas a CSS. Los usuarios de estos programas conocéis las propiedades de opacidad de las capas. ¿Las reconocéis?")])},function(){var e=this.$createElement,n=this._self._c||e;return n("pre",[n("code",{pre:!0,attrs:{class:"language-css"}},[this._v('@keyframes aniHorizontal {\n  0% {\n    background-position: -100% 0;\n  }\n\n  100% {\n    background-position: 100% 0;\n  }\n}\n\n.datagrid__row {\n  position: relative;\n}\n\n.datagrid__row:before {\n  content: "";\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  animation-name: aniHorizontal;\n  animation-duration: 3.5s;\n  animation-timing-function: linear;\n  animation-iteration-count: infinite;\n  background: linear-gradient(\n    to right,\n    #cccccc 2%,\n    #666666 18%,\n    #cccccc 33%\n  );\n  background-size: 50%;\n}\n')])])},function(){var e=this.$createElement,n=this._self._c||e;return n("pre",[n("code",{pre:!0,attrs:{class:"language-css"}},[this._v(".datagrid__row:before {\n  mix-blend-mode: overlay;\n}\n")])])},function(){var e=this.$createElement,n=this._self._c||e;return n("p",[this._v("Si lo que quieres es crear un Skeleton Screen sobre fondo que no sea blanco o negro, o tienes que soportar IE o Edge, te aconsejo esta "),n("a",{attrs:{href:"http://danilowoz.com/create-vue-content-loader/"}},[this._v("otra solución que utiliza SVG")]),this._v(". Es mucho más compleja, no estoy segura de que puedas hacerlo entre diferentes divs y requiere que utilices un paquete externo pero es la mejor alternativa que he podido encontrar.")])},function(){var e=this.$createElement,n=this._self._c||e;return n("p",[this._v("Si te ha gustado este tutorial o las canciones de la playlist puedes seguirme en "),n("a",{attrs:{href:"https://twitter.com/MarinaAisa"}},[this._v("Twitter")]),this._v(" y continuar la conversación por allí.\n¡Todo feedback es bienvenido! Si crees que hay algo que se puede mejorar me ayudarías muchísimo.")])}]}}}}}}]);