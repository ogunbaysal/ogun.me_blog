(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{213:function(e,n){e.exports={body:'## Qué es Vuex\n\nAbreviadamente, [Vuex](https://vuex.vuejs.org/) te permite centralizar información y funciones de la app que son accesibles a través de cualquier componente.\n\n## Qué problema resuelve\n\nCuando trabajas con una librería como Vue, la información de los componentes se transporta de componente padre a componente hijo a través de "props" y viceversa a través de emitir un evento que escuchará el padre. Hay algunas veces que necesitas acceder a información de un componente desde otro sin que tengan la relación de padre e hijo. ¿Cómo la vas a obtener entonces? Técnicamente se puede hacer, pero además de ser una movida acabas con lógica de negocio repartida por cualquier componente que seguramente se repita y que en aplicaciones grandes puede ser un drama. Aquí es donde entra la centralización de esa información con herramientras como Vuex (en Vue) o Redux (en React). No solo puedes centralizar información sino también funciones. \n\n## La estructura para utilizar Vuex\nVuex se distribuye de la siguiente manera:\n\n- **Estado** (en el código <inline-code>state</inline-code>):\n  - Es un objeto que puede contener cualquier tipo de información: strings, arrays u otros objetos.\n  - Es la información que almacenamos de forma centralizada en toda la app.\n- **Mutaciones** (en el código <inline-code>mutations</inline-code>):\n  - Son funciones.\n  - Son las únicas funciones que pueden modificar el estado.\n  - Son llamadas por las acciones.\n  - Se pueden inicializar en el componente a utilizar a través de commit o inicializarse a través de una acción.\n  - Son síncronas.\n- **Acciones** (en el código <inline-code>actions</inline-code>):\n  - Son funciones.\n  - Poseen la lógica de negocio.\n  - Para cambiar el estado deben de llamar a mutaciones a través de *commit*.\n  - Pueden llamar otras acciones a través de *dispatch*. \n  - La forma de inicializarse en el componente es a través de *dispatch* o utilizando modulos.\n  - Son asíncronas.\n- **Getters** (en el código <inline-code>getters</inline-code>).\n  - Son funciones.\n  - No cambian el estado pero sí que lo formatean para que podemos utilizar esa información de la manera que la necesitemos.\n  - Sería lo más parecido a una propiedad *computed* en el componente. \n  - Un ejemplo sería una función que filtrara el estado. No lo modifica pero te devuelve un nuevo objeto diferente con los datos filtrados que necesitas.\n\n## Cómo y por qué yo lo utilicé mal\n\n**¡El hecho de que exista Vuex no quiere decir que todas las aplicaciones lo necesiten! Para nada.** Recordemos que Vuex tiene sentido si se reutiliza el código o si hay si hay componentes distantes que necesiten comunicarse. No tiene sentido que hagas un getter si solo lo vas a utilizar una vez y no se comunica con otro componente, para eso crea una propiedad computed en el mismo componente que lo necesita.\n\nPero yo como era una novata, pensé que esta idea de centralización de información me vendría de lujo para crear esta web con blog que expliqué en este <nuxt-link to="/es/blog/blog-usando-vue-nuxt-markdown">post</nuxt-link>. En un primer paso pensé en importar todos los archivos markdown en mi webapp de una sola vez a través de una acción que comitearía una mutación para terminar guardando todos los posts en el estado. Así, después tendría acceso desde el estado a todos los posts o a uno solo, según necesitara en cada componente. Por ejemplo, en la página dinámica de cada post simplemente haría algo así y obtendría el post que busco:\n\n```javascript\ndata () {\n  const blogs = this.$store.state[this.$i18n.locale].blogs\n  return {\n    blog: blogs[params.slug]\n  }\n}\n```\n\nNo utilizo módulos de Vuex en el ejemplo porque así se entiende mejor. Simplemente estamos llamando al estado que lo tenemos configurado como un array con los idiomas de la página, (en este caso queremos que solo nos saque los del idioma actual) y el tipo de información que queremos (en este caso queremos blogs).\nDevolvemos un objeto que será el objeto de la URL del post que coincida con el array blogs.\n\nEn teoría el estado lo reutilizaría muchas veces, por ejemplo, para sacar todos los posts en la página home de la web.\n\nAsí lo hice, tenía sentido hasta aquí o eso creía. PERO NO. Estaba muy equivocada. PENSÉMOSLO MEJOR.\n\nEl principal problema de cómo había planteado Vuex era la ESCALABILIDAD. No es que sea un problema de Vuex, sino de cómo yo lo había construido al no tener en cuenta cómo funciona.\n\nHabía planteado una importación de todos los markdown en Vuex donde los guardaba y gestionaba desde allí. Al guardarlos en Vuex, se ejecutaban en la primera carga en el JS inicial todos los posts y cuantos más posts tuviera más grande sería y más tardaría en cargar la web. Eso sí, una vez pasaba la primera carga, la web volaba de rápido... pero no tenía ningún sentido a nivel de escalabilidad.\n\n**Te voy a explicar mi gran error con Vuex en un ejemplo no técnico:** Pensando que no caduca la leche, es como si en vez de comprar una caja de leche en el supermercado cuando la necesitaras, compraras la primera vez todas las cajas de leche que vas a consumir en tu vida y las guardaras en casa. El coste inicial sería tremendo y no tiene sentido guardar cosas que no vas a utilizar en ese momento, eso sí, no tendrías que volver a ir al supermercado.\n\nEste error, como tantos que me he ido encontrando en este proyecto sola, me sirvió para aprender bastante de Vuex y de cuando utilizarlo y cuando no, con eso me quedo.\n\nPor suerte me dí cuenta de mi error antes de publicar la web y pude cambiar el sistema de importación. Escribí un post sobre cómo hice esta importación dinámica <nuxt-link to="/es/blog/blog-usando-vue-nuxt-markdown"> aquí</nuxt-link>.\n\nComo no tengo comentarios en el blog, me encantaría continuar la conversación en [Twitter](https://twitter.com/MarinaAisa). ¡Todo feedback es bienvenido! Si crees que hay algo que se puede mejorar me ayudarías muchísimo.',html:'<h2>Qué es Vuex</h2>\n<p>Abreviadamente, <a href="https://vuex.vuejs.org/">Vuex</a> te permite centralizar información y funciones de la app que son accesibles a través de cualquier componente.</p>\n<h2>Qué problema resuelve</h2>\n<p>Cuando trabajas con una librería como Vue, la información de los componentes se transporta de componente padre a componente hijo a través de &quot;props&quot; y viceversa a través de emitir un evento que escuchará el padre. Hay algunas veces que necesitas acceder a información de un componente desde otro sin que tengan la relación de padre e hijo. ¿Cómo la vas a obtener entonces? Técnicamente se puede hacer, pero además de ser una movida acabas con lógica de negocio repartida por cualquier componente que seguramente se repita y que en aplicaciones grandes puede ser un drama. Aquí es donde entra la centralización de esa información con herramientras como Vuex (en Vue) o Redux (en React). No solo puedes centralizar información sino también funciones.</p>\n<h2>La estructura para utilizar Vuex</h2>\n<p>Vuex se distribuye de la siguiente manera:</p>\n<ul>\n<li><strong>Estado</strong> (en el código <inline-code>state</inline-code>):\n<ul>\n<li>Es un objeto que puede contener cualquier tipo de información: strings, arrays u otros objetos.</li>\n<li>Es la información que almacenamos de forma centralizada en toda la app.</li>\n</ul>\n</li>\n<li><strong>Mutaciones</strong> (en el código <inline-code>mutations</inline-code>):\n<ul>\n<li>Son funciones.</li>\n<li>Son las únicas funciones que pueden modificar el estado.</li>\n<li>Son llamadas por las acciones.</li>\n<li>Se pueden inicializar en el componente a utilizar a través de commit o inicializarse a través de una acción.</li>\n<li>Son síncronas.</li>\n</ul>\n</li>\n<li><strong>Acciones</strong> (en el código <inline-code>actions</inline-code>):\n<ul>\n<li>Son funciones.</li>\n<li>Poseen la lógica de negocio.</li>\n<li>Para cambiar el estado deben de llamar a mutaciones a través de <em>commit</em>.</li>\n<li>Pueden llamar otras acciones a través de <em>dispatch</em>.</li>\n<li>La forma de inicializarse en el componente es a través de <em>dispatch</em> o utilizando modulos.</li>\n<li>Son asíncronas.</li>\n</ul>\n</li>\n<li><strong>Getters</strong> (en el código <inline-code>getters</inline-code>).\n<ul>\n<li>Son funciones.</li>\n<li>No cambian el estado pero sí que lo formatean para que podemos utilizar esa información de la manera que la necesitemos.</li>\n<li>Sería lo más parecido a una propiedad <em>computed</em> en el componente.</li>\n<li>Un ejemplo sería una función que filtrara el estado. No lo modifica pero te devuelve un nuevo objeto diferente con los datos filtrados que necesitas.</li>\n</ul>\n</li>\n</ul>\n<h2>Cómo y por qué yo lo utilicé mal</h2>\n<p><strong>¡El hecho de que exista Vuex no quiere decir que todas las aplicaciones lo necesiten! Para nada.</strong> Recordemos que Vuex tiene sentido si se reutiliza el código o si hay si hay componentes distantes que necesiten comunicarse. No tiene sentido que hagas un getter si solo lo vas a utilizar una vez y no se comunica con otro componente, para eso crea una propiedad computed en el mismo componente que lo necesita.</p>\n<p>Pero yo como era una novata, pensé que esta idea de centralización de información me vendría de lujo para crear esta web con blog que expliqué en este <nuxt-link to="/es/blog/blog-usando-vue-nuxt-markdown">post</nuxt-link>. En un primer paso pensé en importar todos los archivos markdown en mi webapp de una sola vez a través de una acción que comitearía una mutación para terminar guardando todos los posts en el estado. Así, después tendría acceso desde el estado a todos los posts o a uno solo, según necesitara en cada componente. Por ejemplo, en la página dinámica de cada post simplemente haría algo así y obtendría el post que busco:</p>\n<pre><code class="language-javascript">data () {\n  const blogs = this.$store.state[this.$i18n.locale].blogs\n  return {\n    blog: blogs[params.slug]\n  }\n}\n</code></pre>\n<p>No utilizo módulos de Vuex en el ejemplo porque así se entiende mejor. Simplemente estamos llamando al estado que lo tenemos configurado como un array con los idiomas de la página, (en este caso queremos que solo nos saque los del idioma actual) y el tipo de información que queremos (en este caso queremos blogs).\nDevolvemos un objeto que será el objeto de la URL del post que coincida con el array blogs.</p>\n<p>En teoría el estado lo reutilizaría muchas veces, por ejemplo, para sacar todos los posts en la página home de la web.</p>\n<p>Así lo hice, tenía sentido hasta aquí o eso creía. PERO NO. Estaba muy equivocada. PENSÉMOSLO MEJOR.</p>\n<p>El principal problema de cómo había planteado Vuex era la ESCALABILIDAD. No es que sea un problema de Vuex, sino de cómo yo lo había construido al no tener en cuenta cómo funciona.</p>\n<p>Había planteado una importación de todos los markdown en Vuex donde los guardaba y gestionaba desde allí. Al guardarlos en Vuex, se ejecutaban en la primera carga en el JS inicial todos los posts y cuantos más posts tuviera más grande sería y más tardaría en cargar la web. Eso sí, una vez pasaba la primera carga, la web volaba de rápido... pero no tenía ningún sentido a nivel de escalabilidad.</p>\n<p><strong>Te voy a explicar mi gran error con Vuex en un ejemplo no técnico:</strong> Pensando que no caduca la leche, es como si en vez de comprar una caja de leche en el supermercado cuando la necesitaras, compraras la primera vez todas las cajas de leche que vas a consumir en tu vida y las guardaras en casa. El coste inicial sería tremendo y no tiene sentido guardar cosas que no vas a utilizar en ese momento, eso sí, no tendrías que volver a ir al supermercado.</p>\n<p>Este error, como tantos que me he ido encontrando en este proyecto sola, me sirvió para aprender bastante de Vuex y de cuando utilizarlo y cuando no, con eso me quedo.</p>\n<p>Por suerte me dí cuenta de mi error antes de publicar la web y pude cambiar el sistema de importación. Escribí un post sobre cómo hice esta importación dinámica <nuxt-link to="/es/blog/blog-usando-vue-nuxt-markdown"> aquí</nuxt-link>.</p>\n<p>Como no tengo comentarios en el blog, me encantaría continuar la conversación en <a href="https://twitter.com/MarinaAisa">Twitter</a>. ¡Todo feedback es bienvenido! Si crees que hay algo que se puede mejorar me ayudarías muchísimo.</p>\n',attributes:{name:"vuex-que-es-cuando-utilizarlo",title:"Cómo funciona Vuex y cómo lo utilicé mal",year:"23 Enero 2019",color:"#edece7",isTextColorDark:!0,trans:"vuex-what-is-when-use-it",id:"vuex-what-when",description:"Conceptos básicos de Vuex, cómo empeoré la performance de mi web con ello y por qué.\n",_meta:{resourcePath:"/var/www/html/nuxt-markdown-blog-starter/contents/tr/blog/vuex-que-es-cuando-utilizarlo.md"}},vue:{render:'return function render() { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'div\',{staticClass:"dynamicMarkdown"},[_c(\'h2\',[_vm._v("Qué es Vuex")]),_vm._v(" "),_vm._m(0),_vm._v(" "),_c(\'h2\',[_vm._v("Qué problema resuelve")]),_vm._v(" "),_c(\'p\',[_vm._v("Cuando trabajas con una librería como Vue, la información de los componentes se transporta de componente padre a componente hijo a través de \\"props\\" y viceversa a través de emitir un evento que escuchará el padre. Hay algunas veces que necesitas acceder a información de un componente desde otro sin que tengan la relación de padre e hijo. ¿Cómo la vas a obtener entonces? Técnicamente se puede hacer, pero además de ser una movida acabas con lógica de negocio repartida por cualquier componente que seguramente se repita y que en aplicaciones grandes puede ser un drama. Aquí es donde entra la centralización de esa información con herramientras como Vuex (en Vue) o Redux (en React). No solo puedes centralizar información sino también funciones.")]),_vm._v(" "),_c(\'h2\',[_vm._v("La estructura para utilizar Vuex")]),_vm._v(" "),_c(\'p\',[_vm._v("Vuex se distribuye de la siguiente manera:")]),_vm._v(" "),_c(\'ul\',[_c(\'li\',[_c(\'strong\',[_vm._v("Estado")]),_vm._v(" (en el código "),_c(\'inline-code\',[_vm._v("state")]),_vm._v("):\\n"),_vm._m(1)],1),_vm._v(" "),_c(\'li\',[_c(\'strong\',[_vm._v("Mutaciones")]),_vm._v(" (en el código "),_c(\'inline-code\',[_vm._v("mutations")]),_vm._v("):\\n"),_vm._m(2)],1),_vm._v(" "),_c(\'li\',[_c(\'strong\',[_vm._v("Acciones")]),_vm._v(" (en el código "),_c(\'inline-code\',[_vm._v("actions")]),_vm._v("):\\n"),_vm._m(3)],1),_vm._v(" "),_c(\'li\',[_c(\'strong\',[_vm._v("Getters")]),_vm._v(" (en el código "),_c(\'inline-code\',[_vm._v("getters")]),_vm._v(").\\n"),_vm._m(4)],1)]),_vm._v(" "),_c(\'h2\',[_vm._v("Cómo y por qué yo lo utilicé mal")]),_vm._v(" "),_vm._m(5),_vm._v(" "),_c(\'p\',[_vm._v("Pero yo como era una novata, pensé que esta idea de centralización de información me vendría de lujo para crear esta web con blog que expliqué en este "),_c(\'nuxt-link\',{attrs:{"to":"/es/blog/blog-usando-vue-nuxt-markdown"}},[_vm._v("post")]),_vm._v(". En un primer paso pensé en importar todos los archivos markdown en mi webapp de una sola vez a través de una acción que comitearía una mutación para terminar guardando todos los posts en el estado. Así, después tendría acceso desde el estado a todos los posts o a uno solo, según necesitara en cada componente. Por ejemplo, en la página dinámica de cada post simplemente haría algo así y obtendría el post que busco:")],1),_vm._v(" "),_vm._m(6),_vm._v(" "),_c(\'p\',[_vm._v("No utilizo módulos de Vuex en el ejemplo porque así se entiende mejor. Simplemente estamos llamando al estado que lo tenemos configurado como un array con los idiomas de la página, (en este caso queremos que solo nos saque los del idioma actual) y el tipo de información que queremos (en este caso queremos blogs).\\nDevolvemos un objeto que será el objeto de la URL del post que coincida con el array blogs.")]),_vm._v(" "),_c(\'p\',[_vm._v("En teoría el estado lo reutilizaría muchas veces, por ejemplo, para sacar todos los posts en la página home de la web.")]),_vm._v(" "),_c(\'p\',[_vm._v("Así lo hice, tenía sentido hasta aquí o eso creía. PERO NO. Estaba muy equivocada. PENSÉMOSLO MEJOR.")]),_vm._v(" "),_c(\'p\',[_vm._v("El principal problema de cómo había planteado Vuex era la ESCALABILIDAD. No es que sea un problema de Vuex, sino de cómo yo lo había construido al no tener en cuenta cómo funciona.")]),_vm._v(" "),_c(\'p\',[_vm._v("Había planteado una importación de todos los markdown en Vuex donde los guardaba y gestionaba desde allí. Al guardarlos en Vuex, se ejecutaban en la primera carga en el JS inicial todos los posts y cuantos más posts tuviera más grande sería y más tardaría en cargar la web. Eso sí, una vez pasaba la primera carga, la web volaba de rápido... pero no tenía ningún sentido a nivel de escalabilidad.")]),_vm._v(" "),_vm._m(7),_vm._v(" "),_c(\'p\',[_vm._v("Este error, como tantos que me he ido encontrando en este proyecto sola, me sirvió para aprender bastante de Vuex y de cuando utilizarlo y cuando no, con eso me quedo.")]),_vm._v(" "),_c(\'p\',[_vm._v("Por suerte me dí cuenta de mi error antes de publicar la web y pude cambiar el sistema de importación. Escribí un post sobre cómo hice esta importación dinámica "),_c(\'nuxt-link\',{attrs:{"to":"/es/blog/blog-usando-vue-nuxt-markdown"}},[_vm._v(" aquí")]),_vm._v(".")],1),_vm._v(" "),_vm._m(8)]) }',staticRenderFns:'return [function () { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'p\',[_vm._v("Abreviadamente, "),_c(\'a\',{attrs:{"href":"https://vuex.vuejs.org/"}},[_vm._v("Vuex")]),_vm._v(" te permite centralizar información y funciones de la app que son accesibles a través de cualquier componente.")]) },function () { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'ul\',[_c(\'li\',[_vm._v("Es un objeto que puede contener cualquier tipo de información: strings, arrays u otros objetos.")]),_vm._v(" "),_c(\'li\',[_vm._v("Es la información que almacenamos de forma centralizada en toda la app.")])]) },function () { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'ul\',[_c(\'li\',[_vm._v("Son funciones.")]),_vm._v(" "),_c(\'li\',[_vm._v("Son las únicas funciones que pueden modificar el estado.")]),_vm._v(" "),_c(\'li\',[_vm._v("Son llamadas por las acciones.")]),_vm._v(" "),_c(\'li\',[_vm._v("Se pueden inicializar en el componente a utilizar a través de commit o inicializarse a través de una acción.")]),_vm._v(" "),_c(\'li\',[_vm._v("Son síncronas.")])]) },function () { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'ul\',[_c(\'li\',[_vm._v("Son funciones.")]),_vm._v(" "),_c(\'li\',[_vm._v("Poseen la lógica de negocio.")]),_vm._v(" "),_c(\'li\',[_vm._v("Para cambiar el estado deben de llamar a mutaciones a través de "),_c(\'em\',[_vm._v("commit")]),_vm._v(".")]),_vm._v(" "),_c(\'li\',[_vm._v("Pueden llamar otras acciones a través de "),_c(\'em\',[_vm._v("dispatch")]),_vm._v(".")]),_vm._v(" "),_c(\'li\',[_vm._v("La forma de inicializarse en el componente es a través de "),_c(\'em\',[_vm._v("dispatch")]),_vm._v(" o utilizando modulos.")]),_vm._v(" "),_c(\'li\',[_vm._v("Son asíncronas.")])]) },function () { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'ul\',[_c(\'li\',[_vm._v("Son funciones.")]),_vm._v(" "),_c(\'li\',[_vm._v("No cambian el estado pero sí que lo formatean para que podemos utilizar esa información de la manera que la necesitemos.")]),_vm._v(" "),_c(\'li\',[_vm._v("Sería lo más parecido a una propiedad "),_c(\'em\',[_vm._v("computed")]),_vm._v(" en el componente.")]),_vm._v(" "),_c(\'li\',[_vm._v("Un ejemplo sería una función que filtrara el estado. No lo modifica pero te devuelve un nuevo objeto diferente con los datos filtrados que necesitas.")])]) },function () { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'p\',[_c(\'strong\',[_vm._v("¡El hecho de que exista Vuex no quiere decir que todas las aplicaciones lo necesiten! Para nada.")]),_vm._v(" Recordemos que Vuex tiene sentido si se reutiliza el código o si hay si hay componentes distantes que necesiten comunicarse. No tiene sentido que hagas un getter si solo lo vas a utilizar una vez y no se comunica con otro componente, para eso crea una propiedad computed en el mismo componente que lo necesita.")]) },function () { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'pre\',[_c(\'code\',{pre:true,attrs:{"class":"language-javascript"}},[_vm._v("data () {\\n  const blogs = this.$store.state[this.$i18n.locale].blogs\\n  return {\\n    blog: blogs[params.slug]\\n  }\\n}\\n")])]) },function () { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'p\',[_c(\'strong\',[_vm._v("Te voy a explicar mi gran error con Vuex en un ejemplo no técnico:")]),_vm._v(" Pensando que no caduca la leche, es como si en vez de comprar una caja de leche en el supermercado cuando la necesitaras, compraras la primera vez todas las cajas de leche que vas a consumir en tu vida y las guardaras en casa. El coste inicial sería tremendo y no tiene sentido guardar cosas que no vas a utilizar en ese momento, eso sí, no tendrías que volver a ir al supermercado.")]) },function () { var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'p\',[_vm._v("Como no tengo comentarios en el blog, me encantaría continuar la conversación en "),_c(\'a\',{attrs:{"href":"https://twitter.com/MarinaAisa"}},[_vm._v("Twitter")]),_vm._v(". ¡Todo feedback es bienvenido! Si crees que hay algo que se puede mejorar me ayudarías muchísimo.")]) }]',component:{data:function(){return{templateRender:null}},render:function(e){return this.templateRender?this.templateRender():e("div","Rendering")},created:function(){this.templateRender=function(){var e=this,n=e.$createElement,o=e._self._c||n;return o("div",{staticClass:"dynamicMarkdown"},[o("h2",[e._v("Qué es Vuex")]),e._v(" "),e._m(0),e._v(" "),o("h2",[e._v("Qué problema resuelve")]),e._v(" "),o("p",[e._v('Cuando trabajas con una librería como Vue, la información de los componentes se transporta de componente padre a componente hijo a través de "props" y viceversa a través de emitir un evento que escuchará el padre. Hay algunas veces que necesitas acceder a información de un componente desde otro sin que tengan la relación de padre e hijo. ¿Cómo la vas a obtener entonces? Técnicamente se puede hacer, pero además de ser una movida acabas con lógica de negocio repartida por cualquier componente que seguramente se repita y que en aplicaciones grandes puede ser un drama. Aquí es donde entra la centralización de esa información con herramientras como Vuex (en Vue) o Redux (en React). No solo puedes centralizar información sino también funciones.')]),e._v(" "),o("h2",[e._v("La estructura para utilizar Vuex")]),e._v(" "),o("p",[e._v("Vuex se distribuye de la siguiente manera:")]),e._v(" "),o("ul",[o("li",[o("strong",[e._v("Estado")]),e._v(" (en el código "),o("inline-code",[e._v("state")]),e._v("):\n"),e._m(1)],1),e._v(" "),o("li",[o("strong",[e._v("Mutaciones")]),e._v(" (en el código "),o("inline-code",[e._v("mutations")]),e._v("):\n"),e._m(2)],1),e._v(" "),o("li",[o("strong",[e._v("Acciones")]),e._v(" (en el código "),o("inline-code",[e._v("actions")]),e._v("):\n"),e._m(3)],1),e._v(" "),o("li",[o("strong",[e._v("Getters")]),e._v(" (en el código "),o("inline-code",[e._v("getters")]),e._v(").\n"),e._m(4)],1)]),e._v(" "),o("h2",[e._v("Cómo y por qué yo lo utilicé mal")]),e._v(" "),e._m(5),e._v(" "),o("p",[e._v("Pero yo como era una novata, pensé que esta idea de centralización de información me vendría de lujo para crear esta web con blog que expliqué en este "),o("nuxt-link",{attrs:{to:"/es/blog/blog-usando-vue-nuxt-markdown"}},[e._v("post")]),e._v(". En un primer paso pensé en importar todos los archivos markdown en mi webapp de una sola vez a través de una acción que comitearía una mutación para terminar guardando todos los posts en el estado. Así, después tendría acceso desde el estado a todos los posts o a uno solo, según necesitara en cada componente. Por ejemplo, en la página dinámica de cada post simplemente haría algo así y obtendría el post que busco:")],1),e._v(" "),e._m(6),e._v(" "),o("p",[e._v("No utilizo módulos de Vuex en el ejemplo porque así se entiende mejor. Simplemente estamos llamando al estado que lo tenemos configurado como un array con los idiomas de la página, (en este caso queremos que solo nos saque los del idioma actual) y el tipo de información que queremos (en este caso queremos blogs).\nDevolvemos un objeto que será el objeto de la URL del post que coincida con el array blogs.")]),e._v(" "),o("p",[e._v("En teoría el estado lo reutilizaría muchas veces, por ejemplo, para sacar todos los posts en la página home de la web.")]),e._v(" "),o("p",[e._v("Así lo hice, tenía sentido hasta aquí o eso creía. PERO NO. Estaba muy equivocada. PENSÉMOSLO MEJOR.")]),e._v(" "),o("p",[e._v("El principal problema de cómo había planteado Vuex era la ESCALABILIDAD. No es que sea un problema de Vuex, sino de cómo yo lo había construido al no tener en cuenta cómo funciona.")]),e._v(" "),o("p",[e._v("Había planteado una importación de todos los markdown en Vuex donde los guardaba y gestionaba desde allí. Al guardarlos en Vuex, se ejecutaban en la primera carga en el JS inicial todos los posts y cuantos más posts tuviera más grande sería y más tardaría en cargar la web. Eso sí, una vez pasaba la primera carga, la web volaba de rápido... pero no tenía ningún sentido a nivel de escalabilidad.")]),e._v(" "),e._m(7),e._v(" "),o("p",[e._v("Este error, como tantos que me he ido encontrando en este proyecto sola, me sirvió para aprender bastante de Vuex y de cuando utilizarlo y cuando no, con eso me quedo.")]),e._v(" "),o("p",[e._v("Por suerte me dí cuenta de mi error antes de publicar la web y pude cambiar el sistema de importación. Escribí un post sobre cómo hice esta importación dinámica "),o("nuxt-link",{attrs:{to:"/es/blog/blog-usando-vue-nuxt-markdown"}},[e._v(" aquí")]),e._v(".")],1),e._v(" "),e._m(8)])},this.$options.staticRenderFns=[function(){var e=this.$createElement,n=this._self._c||e;return n("p",[this._v("Abreviadamente, "),n("a",{attrs:{href:"https://vuex.vuejs.org/"}},[this._v("Vuex")]),this._v(" te permite centralizar información y funciones de la app que son accesibles a través de cualquier componente.")])},function(){var e=this.$createElement,n=this._self._c||e;return n("ul",[n("li",[this._v("Es un objeto que puede contener cualquier tipo de información: strings, arrays u otros objetos.")]),this._v(" "),n("li",[this._v("Es la información que almacenamos de forma centralizada en toda la app.")])])},function(){var e=this,n=e.$createElement,o=e._self._c||n;return o("ul",[o("li",[e._v("Son funciones.")]),e._v(" "),o("li",[e._v("Son las únicas funciones que pueden modificar el estado.")]),e._v(" "),o("li",[e._v("Son llamadas por las acciones.")]),e._v(" "),o("li",[e._v("Se pueden inicializar en el componente a utilizar a través de commit o inicializarse a través de una acción.")]),e._v(" "),o("li",[e._v("Son síncronas.")])])},function(){var e=this,n=e.$createElement,o=e._self._c||n;return o("ul",[o("li",[e._v("Son funciones.")]),e._v(" "),o("li",[e._v("Poseen la lógica de negocio.")]),e._v(" "),o("li",[e._v("Para cambiar el estado deben de llamar a mutaciones a través de "),o("em",[e._v("commit")]),e._v(".")]),e._v(" "),o("li",[e._v("Pueden llamar otras acciones a través de "),o("em",[e._v("dispatch")]),e._v(".")]),e._v(" "),o("li",[e._v("La forma de inicializarse en el componente es a través de "),o("em",[e._v("dispatch")]),e._v(" o utilizando modulos.")]),e._v(" "),o("li",[e._v("Son asíncronas.")])])},function(){var e=this,n=e.$createElement,o=e._self._c||n;return o("ul",[o("li",[e._v("Son funciones.")]),e._v(" "),o("li",[e._v("No cambian el estado pero sí que lo formatean para que podemos utilizar esa información de la manera que la necesitemos.")]),e._v(" "),o("li",[e._v("Sería lo más parecido a una propiedad "),o("em",[e._v("computed")]),e._v(" en el componente.")]),e._v(" "),o("li",[e._v("Un ejemplo sería una función que filtrara el estado. No lo modifica pero te devuelve un nuevo objeto diferente con los datos filtrados que necesitas.")])])},function(){var e=this.$createElement,n=this._self._c||e;return n("p",[n("strong",[this._v("¡El hecho de que exista Vuex no quiere decir que todas las aplicaciones lo necesiten! Para nada.")]),this._v(" Recordemos que Vuex tiene sentido si se reutiliza el código o si hay si hay componentes distantes que necesiten comunicarse. No tiene sentido que hagas un getter si solo lo vas a utilizar una vez y no se comunica con otro componente, para eso crea una propiedad computed en el mismo componente que lo necesita.")])},function(){var e=this.$createElement,n=this._self._c||e;return n("pre",[n("code",{pre:!0,attrs:{class:"language-javascript"}},[this._v("data () {\n  const blogs = this.$store.state[this.$i18n.locale].blogs\n  return {\n    blog: blogs[params.slug]\n  }\n}\n")])])},function(){var e=this.$createElement,n=this._self._c||e;return n("p",[n("strong",[this._v("Te voy a explicar mi gran error con Vuex en un ejemplo no técnico:")]),this._v(" Pensando que no caduca la leche, es como si en vez de comprar una caja de leche en el supermercado cuando la necesitaras, compraras la primera vez todas las cajas de leche que vas a consumir en tu vida y las guardaras en casa. El coste inicial sería tremendo y no tiene sentido guardar cosas que no vas a utilizar en ese momento, eso sí, no tendrías que volver a ir al supermercado.")])},function(){var e=this.$createElement,n=this._self._c||e;return n("p",[this._v("Como no tengo comentarios en el blog, me encantaría continuar la conversación en "),n("a",{attrs:{href:"https://twitter.com/MarinaAisa"}},[this._v("Twitter")]),this._v(". ¡Todo feedback es bienvenido! Si crees que hay algo que se puede mejorar me ayudarías muchísimo.")])}]}}}}}}]);